count = 6000;
maxheight = 2;
threadsPerBlock = 508;

long currKnode[10000], offset[10000];

typedef struct knode {
        int location;
        int indices [509];
        int  keys [509];
        bool is_leaf;
        int num_keys;
} knode;

####Annotation Begins####
for(bid = 0; bid < count; bid++){
    for(i = 0; i < maxheight; i++){ //FRATIO2
        for(thid = 0; thid < threadsPerBlock; thid++){
            if((knodes[currKnode[bid]].keys[thid] <= start[bid]) && (knodes[currKnode[bid]].keys[thid+1] > start[bid])){	//taken for less than 1% of the iterations of threadsPerBlock //BRATIO0.01
                if(knodes[currKnode[bid]].indices[thid] < knodes_elem){		//only taken once for every iteration of maxheight  //BRATIO0.5 //BRATIO0.01
                    offset[bid] = knodes[currKnode[bid]].indices[thid];
                }
            }
            if((knodes[lastKnode[bid]].keys[thid] <= end[bid]) && (knodes[lastKnode[bid]].keys[thid+1] > end[bid])){	//taken for less than 1% of the iterations of threadsPerBlock #BRATIO0.01
                if(knodes[lastKnode[bid]].indices[thid] < knodes_elem){		//only taken once for every iteration of maxheight //BRATIO0.01 BRATIO0.5
                    offset_2[bid] = knodes[lastKnode[bid]].indices[thid];
                }
            }
        }
        currKnode[bid] = offset[bid];
        lastKnode[bid] = offset_2[bid];
    }
    for(thid = 0; thid < threadsPerBlock; thid++){
        if(knodes[currKnode[bid]].keys[thid] == start[bid]){				//only taken once for each iteration of count //BRATIO0.0001
            recstart[bid] = knodes[currKnode[bid]].indices[thid];
        }
    }
    for(thid = 0; thid < threadsPerBlock; thid++){
        if(knodes[lastKnode[bid]].keys[thid] == end[bid]){				//only taken once for each iteration of count //BRATIO0.0001
            reclength[bid] = knodes[lastKnode[bid]].indices[thid] - recstart[bid]+1;
        }
    }
}
####Annotation Ends####
